% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{rotating}
\usetikzlibrary{decorations.pathreplacing,shapes,arrows,positioning}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\begin{document}
\bibliographystyle{plainurl}

%
\title{Compiling Files in Parallel: A Study with GCC\thanks{Supported by organization x.}}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Giuliano Belinassi\inst{1} \and Richard Biener\inst{2} \and
Alfredo Goldman\inst{1}}
%
\authorrunning{F. Author et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Institute of Mathematics and Statistics, São Paulo SP, BRA\\
\url{https://www.ime.usp.br} \and
SuSE Labs, Nürnberg 90409, GER\\
\url{https://www.suse.com/}}

%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}

Processors are becoming increasingly parallel over time, but compiling
software has so far been a task parallelizable only by the number of
files in it. To improve compilation parallelism granularity, we propose
a method feasible to implement in commercial compilers for single file
parallel compilation, with simple modifications in the Link Time
Optimization (LTO) engine in compilers; which we show by implementing
it in GCC. This method resulted in a 20\% speedup when self-compiling
GCC in this mode, and we found no meaningful slowdown when compiling
other applications. We also briefly discuss how this impacts the
Reproducible Builds project.

\keywords{Compilers \and Parallel Compilation \and Link Time Optimization \and LTO.}
\end{abstract}
%
%
%
\section{Introduction}

The recent advances in both technological and computational fields induced an
increasingly faster expansion of software ecosystems. Developers create new
programs to supply the needs of the most diverse domains, either through web
systems coded in script languages; or by components to an operating system
destined to control some hardware resources. Independently of the reason behind
the development of such systems, it is true that their code will be, in some
point, transformed into machine language by a compiler or assembler, even if it
is executed by an interpreter.

Compilers are enormous programs, largely adopted by industry and academy, where
a great effort was and still is employed so that they produce efficient code --
but without any sacrifice in correctness --. There are huge projects destined
to develop and improve them, such as the GNU Compiler Collections
(GCC\footnote{https://gcc.gnu.org/}) and LLVM\footnote{https://llvm.org/}, capable
of translate several languages such as C, C++, and Fortran, to machine language.

GCC was started by Richard Stallman, with the first public release in March of
1987. Back then, it
only supported C language, but already allowed code generation for several
architectures \cite{gcc-first-ver}. Initially designed to compile programs a
single file at time, it could not allow global cross-file optimizations because
the compiler never had the opportunity to analyze the program as a whole. This
changed when Link Time Optimization (LTO) was proposed \cite{whoprgoogle} and
implemented in GCC \cite{glek2010optimizing}. LTO can be enabled in GCC by
using \texttt{-flto}.

In this paper we will present (1) the previous efforts in compile a single
file in parallel, (2) an introduction to how LTO works in GCC, (3) our
proposed changes to LTO for single-file compilation, (4) Results, and
future works and how to improve from here.

\section{Related Works}

Related works with parallel compilation also includes \textit{Parallel Parsing}.
Given an alphabet
$\mathrm{\Sigma}$, parsing can be described as building a machine to decide if
an input string $w \in \mathrm{\Sigma}^*$ is a member of a certain language $L
\subseteq \mathrm{\Sigma}^*$ or not, creating the Abstract Syntax Tree in the
process by logging the used derivation rules.  Parallel Compilation includes
parsing (parallel or not), but also includes how to perform analysis,
optimization, and code translation in parallel.

Parallel Parsing dates back from the 1970. \cite{Lincoln:1970:PPT:987475.987478}
explored how to use the vectorial registers in the (so far)
STAR-100 supercomputer for lexical analysis.
\cite{fischer1975parsing} give a detailed theoretical study, proving
several concurrent parsing techniques for LR($k$), LALR($k$) and SLR($k$).
It proceeds by breaking the input in several arbitrary parts, and running a
serial parser on each of these parts. Then the algorithm tries to
recover the stack of each noninitial parser by constructing a set of
possible states, for which there are 5 possible cases. However, in case
of an error, the parser result should be discarded, and therefore a lot
of work will be done in vain when comparing with the sequential version.

But perhaps the most interesting work is by
\cite{Barenghi:2015:PPM:2839536.2840146}, where they explore properties of
Operator Precedence Grammars to construct an Yacc-like parser constructor named
PAPAGENO, which generates parallel parsers. The authors managed to describe a
grammar for Lua and JSON parsing, which they used in their tests. The authors
managed a speedup of up to $5.5\times$ when compared to a parser generated by
GNU Bison.

As for parallel compilation \textit{de facto}, there are two relevant works by
\cite{vandevoorde1988parallel} for C , and \cite{wortman1992} for Modula-2+.
The first assumes that every function declaration is in the file headers, but
implements per-function and per-statement parallel compilation, and the second
implements only per-function parallelism.  Speedups ranged from $1.5\times$ to
$6\times$ on a multicore MicroVAX II machine. None of these papers discuss
optimization.

There has been an attempt of parallelizing GCC by threading the GIMPLE
Intraprocedural pass manager \cite{bernardino2020improving}, which resulted in
a speedup of up to $3.35\times$ to this compilation stage, but up to $1.88x$ in
total compilation of a file when extending this technique to the RTL passes.


\subsection{Link Time Optimization (LTO)} \label{lto_section}

The classical compilation scheme loads the content of a module (or file) through
lexical and syntactic analysis, then optimize the code, translate to assembler, and
encapsulate it in an object file. The issue with this scheme is that it can not
see the content of functions outside current module.

As an answer to this, LTO allows cross module optimizations by
postponing optimizations and final translation to a linker wrapper. There, the entire
program can be loaded by the compiler (but more often, just some sort of summary)
and optimizations can be decided globally, as now it has access to other modules. LTO is divided in three steps
\cite{whoprgoogle,glek2010optimizing}:
\begin{itemize}
\item LGEN (\textit{Local Generation}): each module is translated to an Intermediate
Language (IR) and writen to disk as an fake object file. This phase runs serially
on input file (\textit{i.e.} in parallel with regard to the files in the project).

\item WPA (\textit{Whole Program Analysis}): load all translated module and analyze
the program globally by merging all Compilation Units into one. A Compilation Unit
is entire content of a source file (a .c file in C) plus all headers it includes.
Then it generates a log of transformations for the program, and this global
Compilation Unit is partitioned for the next phase. This analysis runs sequentially
to the entire project.

\item LTRANS(\textit{Local Transformations}): apply the transformations generated by
WPA to each partition. Each partition will generate its own object file, which will
have to be linked together in the future. This phase runs in parallel.
\end{itemize}

This process is sketched in Fig. \ref{fig:whopr_build}, where the linker wrapper is
represented by \textit{collect2}, which firstly launch \textit{lto1} in WPA mode, and the second
time it finally launches \textit{ld}. This process can be seen by launching gcc with \texttt{-flto -v}.

\begin{figure}
\tikzstyle{block} = [rectangle, draw, fill=white,
    text width=6em, text centered, rounded corners, node distance=1cm and 0.5cm, minimum height=2em]
\tikzstyle{line} = [draw, -latex]
\begin{center}
\scalebox{0.7}{
\begin{tikzpicture}[node distance = 3cm, auto]
    % Place nodes
    \node [block]              (fonte1) {source1.c};
    \node [block, right= of fonte1]        (fonte2) {source2.cpp};
    \node [block, right= of fonte2]        (fonte3) {source3.f90};
    \node [block, above= of fonte2]         (make)   {Makefile};

    \node [block, below= of fonte1]        (gcc)      {gcc};
    \node [block, below= of fonte2]        (g++)      {g++};
    \node [block, below= of fonte3]        (gfortran) {gfortran};

    \node [block, below= of gcc]           (objeto1) {obj1.o};
    \node [block, below= of g++]           (objeto2) {obj2.o};
    \node [block, below= of gfortran]      (objeto3) {obj3.o};

    \node [block, below= of objeto2]       (gcc_lto) {collect2 (lto1)};

    \node [block, right= of fonte3]            (gcc_ltrans1) {gcc\_ltrans};
    \node [block, right= of gcc_ltrans1]   (gcc_ltrans2) {gcc\_ltrans};
    \node [block, right= of gcc_ltrans2]   (gcc_ltrans3) {gcc\_ltrans};

    \node [block, above= of gcc_ltrans2]       (gcc_wpa) {gcc\_wpa};
    \coordinate[below= of gcc_wpa]            (c2);


    \node [block, below= of gcc_ltrans1]   (obj1) {obj1.o};
    \node [block, below= of gcc_ltrans2]   (obj2) {obj2.o};
    \node [block, below= of gcc_ltrans3]   (obj3) {obj3.o};

    \node [block, below=of obj2]   (ld) {collect2 (LD)};

	\node [block, below=of ld]   (bin) {Binary};

    % Draw edges
    \draw[->]    ([xshift=-0.7em] make.south)   -- (fonte1.north);
    \draw[->]    (make.south)   -- (fonte2.north);
    \draw[->]    ([xshift=+0.7em] make.south)   -- (fonte3.north);

    \draw[->]    (fonte1.south)   -- (gcc.north);
    \draw[->]    (fonte2.south)   -- (g++.north);
    \draw[->]    (fonte3.south)   -- (gfortran.north);

    \draw[->]    (gcc.south)   -- (objeto1.north);
    \draw[->]    (g++.south)   -- (objeto2.north);
    \draw[->]    (gfortran.south)   -- (objeto3.north);

    \draw[->]    (objeto1.south)   -- ([xshift=-0.7em]gcc_lto.north);
    \draw[->]    (objeto2.south)   -- (gcc_lto.north);
    \draw[->]    (objeto3.south)   -- ([xshift=+0.7em]gcc_lto.north);

    %\draw[->]    (gcc_lto.south)   -- (gcc_wpa.north);
 	\draw[->]  (gcc_lto.east) .. controls +(6.5,0) and +(-6.5,0).. (gcc_wpa.west);

    \draw[->]    (gcc_wpa.south)   -- (gcc_ltrans1.north);
    \draw[->]    (gcc_wpa.south)   -- (gcc_ltrans2.north);
    \draw[->]    (gcc_wpa.south)   -- (gcc_ltrans3.north);

    \draw[->]    (gcc_ltrans1.south)   -- (obj1.north);
    \draw[->]    (gcc_ltrans2.south)   -- (obj2.north);
    \draw[->]    (gcc_ltrans3.south)   -- (obj3.north);

    \draw[->]    (obj1.south)   -- ([xshift=-0.7em]ld.north);
    \draw[->]    (obj2.south)   -- (ld.north);
    \draw[->]    (obj3.south)   -- ([xshift=+0.7em]ld.north);

	\draw[->]    (ld.south)   -- (bin.north);
	
	%draw brackets
\draw [decorate,decoration={brace,amplitude=10pt},xshift=-0.5cm,yshift=0pt]
([xshift=-1.3cm]objeto1.south) -- ([xshift=-1.3cm]fonte1.north) node [black,midway,xshift=-0.3cm]
{\footnotesize \begin{turn}{90}LGEN\end{turn}};

\draw [decorate,decoration={brace,amplitude=10pt},xshift=-0.5cm,yshift=0pt]
([xshift=1.3cm]gcc_ltrans3.north) -- ([xshift=1.3cm]obj3.south) node [black,midway,xshift=0.3cm]
{\footnotesize \begin{turn}{-90}LTRANS\end{turn}};


\end{tikzpicture}
}
\end{center}
\caption{Compilation of a program using LTO scheme}
\label{fig:whopr_build}
\end{figure}

\section{A Middle Ground}

As presented in Section \ref{lto_section}, LTO was created to allow expensive
optimizations in industrial sized programs, and has a serial part (WPA), which
might impose a bottleneck on manycore machines. Classical compilation scheme,
however, can not break its Compilation Unit by default, which can also
bottleneck the compilation if it is too large. Can we transplant the
LTO partitioner to the Classical Compilation scheme, and make it work
\textit{without} having the context of the \textit{entire} program?
The answer is \textit{yes}, and we show that by showing the details
of our implementation in GCC.

In this section, we will first discuss the insides of an important
piece of the compiler from the User Experience perspective: the \textit{driver}.

\subsection{The GCC driver}

An large program can be written in several languages, with each of them having
its own compiler. From a Compiler Theory perspective, a compiler is a software
that translates a program from a language $A$ to an language $B$
\cite{dragonbook}.  In the case of GCC, it translates several languages, such
as C, to Assembler of some architecture, such as x86. This means that
encapsulating code in object files, or linking the code in an executable, are
not tasks of the compiler. However, the user can launch \texttt{gcc -o binary
file.c} and get a working binary. That is because the driver will launch the
necessary programs for the user, and in fact this line launches three programs,
as illustrated in Fig. \ref{fig:gnu_toolchain}.

\begin{figure}
\tikzstyle{block} = [rectangle, draw, fill=white,
    text width=6em, text centered, rounded corners, node distance=4.7cm, auto, minimum height=2em]
\tikzstyle{line} = [draw, -latex]
\tikzstyle{cloud} = [draw, ellipse,fill=white, node distance=2cm,
    minimum height=2em]
\begin{center}
\scalebox{0.7}{
\begin{tikzpicture}[node distance = 3cm, auto]
    % Place nodes
    \node [block]                      (cc1) {Compiler \\ (cc1)};
    \node [block, right of = cc1]      (as) {Assembler\\(as)};
    \node [block, right of = as]       (ld) {Linker\\collect2 or ld};
    \coordinate [left of=cc1]          (fonte);
    \coordinate [right of=ld]    (bin);

    % Draw edges
    \draw[->]    (cc1.east)    -- (as.west)       node[midway, above] {Assembler File};
    \draw[->]    (cc1.east)    -- (as.west)       node[midway, below] {(.s)};
    \draw[->]    (as.east)     -- (ld.west)       node[midway, above] {Object File};
    \draw[->]    (as.east)     -- (ld.west)       node[midway, below] {(.o)};
    \draw[->]    (fonte.west)  -- (cc1.west)      node[pos=0, above] {Source File};
    \draw[->]    (fonte.west)  -- (cc1.west)      node[pos=0, below] {(.c)};
    \draw[->]    (ld.east)     -- (bin.west)      node[pos=1, above] {Executable};
\end{tikzpicture}
}
\end{center}
\caption{GCC Compiling a .c file}
\label{fig:gnu_toolchain}
\end{figure}

Therefore, our changes should not break the building scripts (\textit{e.g.} Makefile)
used by most
projects, which is mostly launching \texttt{gcc file.c -c}, which creates
an object file \texttt{file.o}. However, LTO partitioner will create an object file for each partition. This
would result in multiple object files which will be needed by the final
link process.

The solution for this problem is:
\begin{enumerate}
	\item Patch the \textit{partitioner} to communicate the location of
	each files created to the \textit{driver}. If the \textit{partitioner}
	is the compiler (which is the case of GCC), then it should communicate
	the location of each generated \textit{assembler file}. This can be
	archived by passing a hidden flag \texttt{-fadditional-asm=<file>}
	by the driver to the partitioner, which the last will write to. This file can also
	be replaced with a Named Pipe for better performance, if needed.

	Then, check if this flag has been passed to the compiler. If yes, then
	a \textit{compatible version} of the driver is installed. If the
	partitioner decides to partition the Compilation Unit, it should
	\textit{retarget} the destination assembler file, and write the retarget
	name to the communication file.

	\item Patch the driver to pass this hidden flag to the
	\textit{partitioner}.  Then check if this file exist. If not, it means that
	either the compiler is incompatible (assuming it did not halt with an
	error) or it has chosen to not partition the Compilation Unit. Then the
	driver should call \textit{as} to every assembler file generated, and call
	the linker to generate the expected final object file. In GNU \textit{ld},
	it is necessary to enable the \textit{partial linking} flag for linking
	object files into another object file.
\end{enumerate}

\begin{figure}
\tikzstyle{block} = [rectangle, draw, fill=white,
    text width=6em, text centered, rounded corners, node distance=3cm and 3cm, auto, minimum height=2em]
\tikzstyle{line} = [draw, -latex]
\tikzstyle{cloud} = [draw, ellipse,fill=white, node distance=2cm,
    minimum height=2em]
\begin{center}
\scalebox{0.7}{
\begin{tikzpicture}[node distance = 3cm, auto]
    % Place nodes
    \node [block]                      (cc1_1) {cc1};
    \node [block, right= of cc1_1]        (driver1) {Driver};
    \node [block, above= of driver1]                      (cc1_2) {cc1};
    \node [block, below= of driver1]                      (cc1_3) {cc1};
    \node [block, right= of cc1_2]      (as2) {as};
    \node [block, right= of cc1_3]      (as3) {as};
    \node [block, right= of as]       (ld) {ld};
    \coordinate [left= of cc1]          (fonte);
    \coordinate [right= of ld]    (bin);

    % Draw edges
    \draw[->]    (driver1.west)    -- (cc1_1.east) node[midway, above] {\texttt{-fadditional-asm=<file>}};
    \draw[->]    (cc1_2.south) -- (driver1.north) node[midway, above] {Generated .s file};
    \draw[->]    (cc1_3.north) -- (driver1.south) node[midway, above] {Generated .s file};

    \draw[->]    (cc1_1.north)    -- (cc1_2.south) node[midway, above] {forks};
    \draw[->]    (cc1_1.south)    -- (cc1_3.north) node[midway, above] {forks};
    \draw[->]    (cc1_2.east)    -- (as2.west) node[midway, above] {forks};
    \draw[->]    (cc1_3.east)    -- (as3.west) node[midway, above] {forks};

    \draw[->]    (driver1.east)    -- (asm2.west) node[midway, above] {Launches}};
    \draw[->]    (driver1.east)    -- (asm3.west) node[midway, above] {Launches}};

%    \draw[->]    (cc1.east)    -- (as.west)       node[midway, above] {Assembler File};
%    \draw[->]    (cc1.east)    -- (as.west)       node[midway, above] {Assembler File};
%
%    \draw[->]    (cc1.east)    -- (as.west)       node[midway, below] {(.s)};
%    \draw[->]    (as.east)     -- (ld.west)       node[midway, above] {Object File};
%    \draw[->]    (as.east)     -- (ld.west)       node[midway, below] {(.o)};
%    \draw[->]    (fonte.west)  -- (cc1.west)      node[pos=0, above] {Source File};
%    \draw[->]    (fonte.west)  -- (cc1.west)      node[pos=0, below] {(.c)};
    \draw[->]    (ld.east)     -- (bin.west)      node[pos=1, above] {\texttt{file.o}};
\end{tikzpicture}
}
\end{center}
\caption{GCC Compiling a .c file}
\label{fig:gnu_toolchain}
\end{figure}

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
% \bibliographystyle{splncs04}
% \bibliography{mybibliography}
%
%\begin{thebibliography}{8}
%\bibitem{ref_article1}
%Author, F.: Article title. Journal \textbf{2}(5), 99--110 (2016)
%
%\bibitem{ref_lncs1}
%Author, F., Author, S.: Title of a proceedings paper. In: Editor,
%F., Editor, S. (eds.) CONFERENCE 2016, LNCS, vol. 9999, pp. 1--13.
%Springer, Heidelberg (2016). \doi{10.10007/1234567890}
%
%\bibitem{ref_book1}
%Author, F., Author, S., Author, T.: Book title. 2nd edn. Publisher,
%Location (1999)
%
%\bibitem{ref_proc1}
%Author, A.-B.: Contribution title. In: 9th International Proceedings
%on Proceedings, pp. 1--2. Publisher, Location (2010)
%
%\bibitem{ref_url1}
%LNCS Homepage, \url{http://www.springer.com/lncs}. Last accessed 4
%Oct 2017
%\end{thebibliography}

\bibliographystyle{splncs04}
\bibliography{bibliography}

\end{document}
